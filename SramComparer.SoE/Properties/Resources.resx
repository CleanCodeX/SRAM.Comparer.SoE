<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CommandIncludeChecksum" xml:space="preserve">
    <value>Show game checksum</value>
  </data>
  <data name="CommandIncludeAllChecksums" xml:space="preserve">
    <value>Show all game checksums</value>
  </data>
  <data name="CommandIncludeUnknown12B" xml:space="preserve">
    <value>Show game Unknown12Bs</value>
  </data>
  <data name="CommandIncludeAllUnknown12Bs" xml:space="preserve">
    <value>Show all game checksums</value>
  </data>
  <data name="AppManualCommandsTemplate" xml:space="preserve">
    <value>Steps: 
1.1) Have a look into UnknownOffsets.txt to see examples of what parts of SRAM structure are still 
     considered "unknown".
1.2) Most emulators have the option to save the game's S-RAM automatically after a change occurs. 
     Make sure this is enabled if existing. Otherwise you have manually ensure that the emulator updates 
     the srm file.
1.3) Start the tool by passing the game's srm filepath as first command parameter. The file can also be 
     dragged onto the tool.

2)   Switch to this tool and press ({0}) to create/overwrite a comparison copy of your current SRAM file allow
     comparison after your next change of the game's srm file.

3.1) Cause in-game a SRAM change by doing a specific action. (e.g. let a game progress event happen or 
    open a chest) This change needs to be saved in the inn to make the game update the srm file.
3.2) Press ({1}) to compare the current srm file with comparison file. 
     (If the SRAM file did not change at all, you probably did not save in-game or the emulator didn't
     (yet!) update the SRAM (srm) file automatically. Check the modification date of the game's srm file.
     For Example: Snes9x's default srm update period is 30 seconds. Decrease it to a lower value, like 1,
     but not to 0.

4.1) Once you got the offset of the changed value and bit what has changed you've found a meaning for a 
     specific bit/byte. Then press ({2}) to export the comparison result to a textfile in your export 
     directory. 
4.2) Rename the file expressing your current discovery. 
     If it is reproducable, consider to report the exported file to the tool's creator 
     and/or contribute the change to SRAM structure to the tool's github repository.

5)   To start a "fresh" comparison without previous SRAM changes, press again ({0}) to save your current SRAM file 
     as comparison file and start again at step 3.1.

6.1) (optional, advanced) If you have more than one slot with changes to comparison file, press ({3}) to
     set the game's save slot (1-4) to avoid comparing other game slots. If twi different games should be 
     compared with each other, additionally press ({4}) to set the the slot of comparison srm file, too.
6.2) (optional, advanced) Press ({5} | {6}) to set comparison modes. 
     If you are unsure, leave it as it is to compare as less as possible bytes.

7)   (optional) Current and comparison srm file can be backed-up press ({7}|{8}) or restored ({9}|{10}) individually.
    </value>
  </data>
  <data name="ChangesAtEveryInGameSave" xml:space="preserve">
    <value>changes at every in-game save</value>
  </data>
  <data name="GamesCurrentChecksumValues" xml:space="preserve">
    <value>Game's current 'Checksum' values</value>
  </data>
  <data name="GamesCurrentUnknown12BValues" xml:space="preserve">
    <value>Game's current 'UnknownB12' values</value>
  </data>
  <data name="QueuedCommands" xml:space="preserve">
    <value>Queued commands</value>
  </data>
  <data name="ComparedWithGameTemplated" xml:space="preserve">
    <value>compared with game {0}</value>
  </data>
</root>